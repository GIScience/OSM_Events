<html>
<head>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
<script>
// https://github.com/mlevans/leaflet-hash/blob/master/leaflet-hash.js
(function(window) {
	var HAS_HASHCHANGE = (function() {
		var doc_mode = window.documentMode;
		return ('onhashchange' in window) &&
			(doc_mode === undefined || doc_mode > 7);
	})();

	L.Hash = function(map) {
		this.onHashChange = L.Util.bind(this.onHashChange, this);

		if (map) {
			this.init(map);
		}
	};

	L.Hash.parseHash = function(hash) {
		if(hash.indexOf('#') === 0) {
			hash = hash.substr(1);
		}
		var args = hash.split("/");
		if (args.length == 3) {
			var zoom = parseInt(args[0], 10),
			lat = parseFloat(args[1]),
			lon = parseFloat(args[2]);
			if (isNaN(zoom) || isNaN(lat) || isNaN(lon)) {
				return false;
			} else {
				return {
					center: new L.LatLng(lat, lon),
					zoom: zoom
				};
			}
		} else {
			return false;
		}
	};

	L.Hash.formatHash = function(map) {
		var center = map.getCenter(),
		    zoom = map.getZoom(),
		    precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));

		return "#" + [zoom,
			center.lat.toFixed(precision),
			center.lng.toFixed(precision)
		].join("/");
	},

	L.Hash.prototype = {
		map: null,
		lastHash: null,

		parseHash: L.Hash.parseHash,
		formatHash: L.Hash.formatHash,

		init: function(map) {
			this.map = map;

			// reset the hash
			this.lastHash = null;
			this.onHashChange();

			if (!this.isListening) {
				this.startListening();
			}
		},

		removeFrom: function(map) {
			if (this.changeTimeout) {
				clearTimeout(this.changeTimeout);
			}

			if (this.isListening) {
				this.stopListening();
			}

			this.map = null;
		},

		onMapMove: function() {
			// bail if we're moving the map (updating from a hash),
			// or if the map is not yet loaded

			if (this.movingMap || !this.map._loaded) {
				return false;
			}

			var hash = this.formatHash(this.map);
			if (this.lastHash != hash) {
				location.replace(hash);
				this.lastHash = hash;
			}
		},

		movingMap: false,
		update: function() {
			var hash = location.hash;
			if (hash === this.lastHash) {
				return;
			}
			var parsed = this.parseHash(hash);
			if (parsed) {
				this.movingMap = true;

				this.map.setView(parsed.center, parsed.zoom);

				this.movingMap = false;
			} else {
				this.onMapMove(this.map);
			}
		},

		// defer hash change updates every 100ms
		changeDefer: 100,
		changeTimeout: null,
		onHashChange: function() {
			// throttle calls to update() so that they only happen every
			// `changeDefer` ms
			if (!this.changeTimeout) {
				var that = this;
				this.changeTimeout = setTimeout(function() {
					that.update();
					that.changeTimeout = null;
				}, this.changeDefer);
			}
		},

		isListening: false,
		hashChangeInterval: null,
		startListening: function() {
			this.map.on("moveend", this.onMapMove, this);

			if (HAS_HASHCHANGE) {
				L.DomEvent.addListener(window, "hashchange", this.onHashChange);
			} else {
				clearInterval(this.hashChangeInterval);
				this.hashChangeInterval = setInterval(this.onHashChange, 50);
			}
			this.isListening = true;
		},

		stopListening: function() {
			this.map.off("moveend", this.onMapMove, this);

			if (HAS_HASHCHANGE) {
				L.DomEvent.removeListener(window, "hashchange", this.onHashChange);
			} else {
				clearInterval(this.hashChangeInterval);
			}
			this.isListening = false;
		}
	};
	L.hash = function(map) {
		return new L.Hash(map);
	};
	L.Map.prototype.addHash = function() {
		this._hash = L.hash(this);
	};
	L.Map.prototype.removeHash = function() {
		this._hash.removeFrom();
	};
})(window);
</script>
<script>
//https://github.com/teastman/Leaflet.pattern/blob/master/dist/leaflet.pattern.js
/*
 Leaflet.pattern, Provides tools to set the backgrounds of vector shapes in Leaflet to be patterns.
 https://github.com/teastman/Leaflet.pattern
 (c) 2015, Tyler Eastman
*/
!function(t,e){L.Pattern=L.Class.extend({includes:[L.Mixin.Events],options:{x:0,y:0,width:8,height:8,patternUnits:"userSpaceOnUse",patternContentUnits:"userSpaceOnUse"},_addShapes:L.Util.falseFn,_update:L.Util.falseFn,initialize:function(t){this._shapes={},L.setOptions(this,t)},onAdd:function(t){this._map=t.target?t.target:t,this._map._initDefRoot(),this._initDom();for(var e in this._shapes)this._shapes[e].onAdd(this);this._addShapes(),this._addDom(),this.redraw(),this.getEvents&&this._map.on(this.getEvents(),this),this.fire("add"),this._map.fire("patternadd",{pattern:this})},onRemove:function(){this._removeDom()},redraw:function(){if(this._map){this._update();for(var t in this._shapes)this._shapes[t].redraw()}return this},setStyle:function(t){return L.setOptions(this,t),this._map&&(this._updateStyle(),this.redraw()),this},addTo:function(t){return t.addPattern(this),this},remove:function(){return this.removeFrom(this._map)},removeFrom:function(t){return t&&t.removePattern(this),this}}),L.Map.addInitHook(function(){this._patterns={}}),L.Map.include({addPattern:function(t){var e=L.stamp(t);return this._patterns[e]?t:(this._patterns[e]=t,this.whenReady(t.onAdd,t),this)},removePattern:function(t){var e=L.stamp(t);return this._patterns[e]?(this._loaded&&t.onRemove(this),t.getEvents&&this.off(t.getEvents(),t),delete this._patterns[e],this._loaded&&(this.fire("patternremove",{pattern:t}),t.fire("remove")),t._map=null,this):this},hasPattern:function(t){return!!t&&L.stamp(t)in this._patterns}}),L.Pattern.SVG_NS="http://www.w3.org/2000/svg",L.Pattern=L.Pattern.extend({_createElement:function(t){return e.createElementNS(L.Pattern.SVG_NS,t)},_initDom:function(){this._dom=this._createElement("pattern"),this.options.className&&L.DomUtil.addClass(this._dom,this.options.className),this._updateStyle()},_addDom:function(){this._map._defRoot.appendChild(this._dom)},_removeDom:function(){L.DomUtil.remove(this._dom)},_updateStyle:function(){var t=this._dom,e=this.options;if(t){if(t.setAttribute("id",L.stamp(this)),t.setAttribute("x",e.x),t.setAttribute("y",e.y),t.setAttribute("width",e.width),t.setAttribute("height",e.height),t.setAttribute("patternUnits",e.patternUnits),t.setAttribute("patternContentUnits",e.patternContentUnits),e.patternTransform||e.angle){var i=e.patternTransform?e.patternTransform+" ":"";i+=e.angle?"rotate("+e.angle+") ":"",t.setAttribute("patternTransform",i)}else t.removeAttribute("patternTransform");for(var s in this._shapes)this._shapes[s]._updateStyle()}}}),L.Map.include({_initDefRoot:function(){if(!this._defRoot)if("function"==typeof this.getRenderer){var t=this.getRenderer(this);this._defRoot=L.Pattern.prototype._createElement("defs"),t._container.appendChild(this._defRoot)}else this._pathRoot||this._initPathRoot(),this._defRoot=L.Pattern.prototype._createElement("defs"),this._pathRoot.appendChild(this._defRoot)}}),L.SVG?L.SVG.include({_superUpdateStyle:L.SVG.prototype._updateStyle,_updateStyle:function(t){this._superUpdateStyle(t),t.options.fill&&t.options.fillPattern&&t._path.setAttribute("fill","url(#"+L.stamp(t.options.fillPattern)+")")}}):L.Path.include({_superUpdateStyle:L.Path.prototype._updateStyle,_updateStyle:function(){this._superUpdateStyle(),this.options.fill&&this.options.fillPattern&&this._path.setAttribute("fill","url(#"+L.stamp(this.options.fillPattern)+")")}}),L.StripePattern=L.Pattern.extend({options:{weight:4,spaceWeight:4,color:"#000000",spaceColor:"#ffffff",opacity:1,spaceOpacity:0},_addShapes:function(){this._stripe=new L.PatternPath({stroke:!0,weight:this.options.weight,color:this.options.color,opacity:this.options.opacity}),this._space=new L.PatternPath({stroke:!0,weight:this.options.spaceWeight,color:this.options.spaceColor,opacity:this.options.spaceOpacity}),this.addShape(this._stripe),this.addShape(this._space),this._update()},_update:function(){this._stripe.options.d="M0 "+this._stripe.options.weight/2+" H "+this.options.width,this._space.options.d="M0 "+(this._stripe.options.weight+this._space.options.weight/2)+" H "+this.options.width},setStyle:L.Pattern.prototype.setStyle}),L.stripePattern=function(t){return new L.StripePattern(t)},L.PatternShape=L.Class.extend({options:{stroke:!0,color:"#3388ff",weight:3,opacity:1,lineCap:"round",lineJoin:"round",fillOpacity:.2,fillRule:"evenodd"},initialize:function(t){L.setOptions(this,t)},onAdd:function(t){this._pattern=t,this._pattern._dom&&(this._initDom(),this._addDom())},addTo:function(t){return t.addShape(this),this},redraw:function(){return this._pattern&&this._updateShape(),this},setStyle:function(t){return L.setOptions(this,t),this._pattern&&this._updateStyle(),this},setShape:function(t){this.options=L.extend({},this.options,t),this._updateShape()}}),L.Pattern.include({addShape:function(t){var e=L.stamp(t);return this._shapes[e]?t:(this._shapes[e]=t,t.onAdd(this),void 0)}}),L.PatternShape.SVG_NS="http://www.w3.org/2000/svg",L.PatternShape=L.PatternShape.extend({_createElement:function(t){return e.createElementNS(L.PatternShape.SVG_NS,t)},_initDom:L.Util.falseFn,_updateShape:L.Util.falseFn,_initDomElement:function(t){this._dom=this._createElement(t),this.options.className&&L.DomUtil.addClass(this._dom,this.options.className),this._updateStyle()},_addDom:function(){this._pattern._dom.appendChild(this._dom)},_updateStyle:function(){var t=this._dom,e=this.options;t&&(e.stroke?(t.setAttribute("stroke",e.color),t.setAttribute("stroke-opacity",e.opacity),t.setAttribute("stroke-width",e.weight),t.setAttribute("stroke-linecap",e.lineCap),t.setAttribute("stroke-linejoin",e.lineJoin),e.dashArray?t.setAttribute("stroke-dasharray",e.dashArray):t.removeAttribute("stroke-dasharray"),e.dashOffset?t.setAttribute("stroke-dashoffset",e.dashOffset):t.removeAttribute("stroke-dashoffset")):t.setAttribute("stroke","none"),e.fill?(e.fillPattern?t.setAttribute("fill","url(#"+L.stamp(e.fillPattern)+")"):t.setAttribute("fill",e.fillColor||e.color),t.setAttribute("fill-opacity",e.fillOpacity),t.setAttribute("fill-rule",e.fillRule||"evenodd")):t.setAttribute("fill","none"),t.setAttribute("pointer-events",e.pointerEvents||(e.interactive?"visiblePainted":"none")))}}),L.PatternPath=L.PatternShape.extend({_initDom:function(){this._initDomElement("path")},_updateShape:function(){this._dom&&this._dom.setAttribute("d",this.options.d)}}),L.PatternCircle=L.PatternShape.extend({options:{x:0,y:0,radius:0},_initDom:function(){this._initDomElement("circle")},_updateShape:function(){this._dom&&(this._dom.setAttribute("cx",this.options.x),this._dom.setAttribute("cy",this.options.y),this._dom.setAttribute("r",this.options.radius))}}),L.PatternRect=L.PatternShape.extend({options:{x:0,y:0,width:10,height:10},_initDom:function(){this._initDomElement("rect")},_updateShape:function(){this._dom&&(this._dom.setAttribute("x",this.options.x),this._dom.setAttribute("y",this.options.y),this._dom.setAttribute("width",this.options.width),this._dom.setAttribute("height",this.options.height),this.options.rx&&this._dom.setAttribute("rx",this.options.rx),this.options.ry&&this._dom.setAttribute("ry",this.options.ry))}})}(window,document);
</script>
<style>
.leaflet-tile-pane img {
  filter: grayscale(1);
}
</style>
</head>
<body>
<div id="map" style="position:absolute; left:0; top:0; right:0; bottom:0;"></div>
<script>
const map = L.map('map').fitWorld();
const baseLayer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: 'Base map and data from <a href="https://www.openstreetmap.org/copyright">OpenStreetMap and OpenStreetMap Foundation</a>',
  maxZoom: 19
}).addTo(map);
new L.Hash(map);

function addGlobalNone(data) {
	const zoomBreak = 4;
	const stripes1 = new L.StripePattern({
		weight: 1,
		spaceWeight: 5,
		color: "#000",
		spaceColor: "#eeeeee",
		opacity: 0.25,
		spaceOpacity: 0.2,
		height: 6,
		angle: -45
	});
	stripes1.addTo(map);
	const stripes2 = new L.StripePattern({
		weight: 1,
		spaceWeight: 3,
		color: "#000",
		spaceColor: "#eeeeee",
		opacity: 0.5,
		spaceOpacity: 0.2,
		height: 4,
		angle: -45
	});
	stripes2.addTo(map);
	const stripeLayer = L.geoJSON(data, {
		style: {
			weight: 0,
			fillPattern: map.getZoom() > zoomBreak ? stripes2 : stripes1,
			fillOpacity: 1
		}
	}).addTo(map);
	var mapZoom = map.getZoom();
	map.on('zoomstart', function () {
		mapZoom = map.getZoom();
	});
	map.on('zoomend', function (e) {
	  const currentZoom = map.getZoom();
	  if (mapZoom > zoomBreak && currentZoom <= zoomBreak) {
	    stripeLayer.setStyle({ fillPattern: stripes1 });
	  } else if (mapZoom <= zoomBreak && currentZoom > zoomBreak) {
	    stripeLayer.setStyle({ fillPattern: stripes2 });
	  }
		mapZoom = map.getZoom();
	});
}

const eventTypes = {
  'Local knowledge event': { max: 100, color: "#e41a1c" },
  'Remote event': { max: 100, color: "#377eb8" },
  'Early import': { max: 100, color: "#4daf4a" },
  'Geometry import': { max: 100, color: "#984ea3" },
  'Late import': { max: 100, color: "#ff7f00" },
  'Tag import': { max: 100, color: "#ffff33" },
}
const dataLayers = {};
Object.keys(eventTypes).forEach(type => {
  dataLayers[type] = L.geoJSON(undefined, {
    style: feature => ({
      weight: 0,
      fillColor: eventTypes[type].color,
      fillOpacity: (feature.properties['events'][type] || 0) / eventTypes[type].max
    }),
    smoothFactor: 0
  });
});

Promise.all([
  fetch('./grid_20000_id.geojson').then(data => data.json()),
  fetch('./event_weights_by_cell.csv').then(data => data.text()),
  fetch('./globalNone.geojson').then(data => data.json()),
]).then(data => {
  const grid = data[0];
	const global = data[2];
	addGlobalNone(global);
  const valuesMap = {};
  data[1].split('\n').slice(1, -1).map(l => l.split(',')).forEach(l => {
    valuesMap[l[0]] = {
      'Local knowledge event': l[1],
      'Remote event': l[2],
      'Early import': l[3],
      'Geometry import': l[4],
      'Late import': l[5],
      'Tag import': l[6]
    };
  });
  grid.features.forEach(f => {
    f.properties['events'] = valuesMap[f.properties.id] || {};
  });
  Object.values(dataLayers).forEach(dataLayer => dataLayer.addData(grid));
});

L.Control.Legend = L.Control.extend({
  onAdd: function(map) {
    const container = L.DomUtil.create('div');
		container.style.backgroundColor = 'white';
    container.style.pointerEvents = 'none';
    container.style.padding = '4px 8px';
		container.className = 'leaflet-control-layers';

		const title = L.DomUtil.create('h2');
		title.textContent = 'Legend';
		title.style.fontSize = '14px';
		title.style.fontWeight = 'bold';
		title.style.margin = '0 0 6px 0';
		container.appendChild(title);

    const scale = L.DomUtil.create('div');
		scale.style.position = 'relative';
    scale.style.width = '200px';
    scale.style.height = '18px';
		scale.style.margin = '0 0 8px 0';
    const leftLabel = L.DomUtil.create('span');
    leftLabel.textContent = '0%';
    leftLabel.style.position = 'absolute';
    leftLabel.style.left = '3px';
    scale.appendChild(leftLabel);
    const rightLabel = L.DomUtil.create('span');
    rightLabel.textContent = '100%';
    rightLabel.style.position = 'absolute';
    rightLabel.style.right = '3px';
    scale.appendChild(rightLabel);
    map.on('baselayerchange', l => {
      const color = eventTypes[l.name].color;
      scale.style.background = 'linear-gradient(90deg, ' +
        'rgba(0,0,0,0) 0%, ' +
        color + ' 100%)';
    });
		container.appendChild(scale);

    const stripes = L.DomUtil.create('div');
		stripes.style.margin = '0 0 6px 0';
    const stripesIcon = L.DomUtil.create('div');
		stripesIcon.style.display = 'inline-block';
		stripesIcon.style.verticalAlign = 'baseline';
		stripesIcon.style.width = '40px';
    stripesIcon.style.height = '14px';
		stripesIcon.style.background = 'repeating-linear-gradient( -45deg, gray, gray 0.9px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 6px )';
    const stripesLabel = L.DomUtil.create('span');
		stripesLabel.textContent = 'insufficient data';
		stripesLabel.style.marginLeft = '4px';
		stripes.appendChild(stripesIcon);
		stripes.appendChild(stripesLabel);
		container.appendChild(stripes);

    return container;
  }
});
L.control.legend = function(opts) {
  return new L.Control.Legend(opts);
}
L.control.legend({ position: 'bottomleft' }).addTo(map);

L.control.layers(dataLayers, {}, {
  position: 'bottomleft',
  collapsed: false
}).addTo(map);

dataLayers['Early import'].addTo(map);
</script>
